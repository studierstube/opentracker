<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SoWinViewer class Reference</title>
<link href="stylesheet.css" rel="stylesheet" type="text/css">
</head><body><table width="100%">
<tr>
  <td>
    <img src="Coin_logo.png" alt="Coin Logo">
  </td>
  <td align="right">
    <a href="http://www.sim.no">http://www.sim.no</a><br>
    <a href="http://www.coin3d.org/">http://www.coin3d.org</a>
  </td>
</tr>
</table>
<hr noshade>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<h1>SoWinViewer Class Reference<br>
<small>
[<a class="el" href="group__components.html">Win Components</a>,&nbsp;<a class="el" href="group__viewers.html">Win Viewer Components</a>]</small>
</h1><code>#include &lt;<a class="el" href="SoWinViewer_8h-source.html">Inventor/Win/viewers/SoWinViewer.h</a>&gt;</code>
<p>
<p>Inheritance diagram for SoWinViewer:
<p><center><img src="classSoWinViewer.png" usemap="#SoWinViewer_map" border="0" alt=""></center>
<map name="SoWinViewer_map">
<area href="classSoWinRenderArea.html" alt="SoWinRenderArea" shape="rect" coords="166,168,322,192">
<area href="classSoWinGLWidget.html" alt="SoWinGLWidget" shape="rect" coords="166,112,322,136">
<area href="classSoWinComponent.html" alt="SoWinComponent" shape="rect" coords="166,56,322,80">
<area href="classSoWinObject.html" alt="SoWinObject" shape="rect" coords="166,0,322,24">
<area href="classSoWinFullViewer.html" alt="SoWinFullViewer" shape="rect" coords="166,280,322,304">
<area href="classSoWinConstrainedViewer.html" alt="SoWinConstrainedViewer" shape="rect" coords="0,336,156,360">
<area href="classSoWinExaminerViewer.html" alt="SoWinExaminerViewer" shape="rect" coords="166,336,322,360">
<area href="classSoWinPlaneViewer.html" alt="SoWinPlaneViewer" shape="rect" coords="332,336,488,360">
<area href="classSoWinFlyViewer.html" alt="SoWinFlyViewer" shape="rect" coords="0,392,156,416">
</map>
<a href="classSoWinViewer-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
The SoWinViewer class is the top level base viewer class. 
<p>
This is an abstract class, which adds the following features to it's <a class="el" href="classSoWinRenderArea.html">SoWinRenderArea</a> superclass: convenient methods for camera handling, an automatic headlight configuration.<p>
As for the camera handling: when setting a new scenegraph for the viewer, the scenegraph will automatically be scanned for a node derived from SoCamera. If not found, the viewer will itself set up a camera for the scene. The camera can then be conveniently controlled by the application programmers in many aspects:<p>
<ul>
<li>
camera type: toggle between using an orthographic camera and a perspective camera with <a class="el" href="classSoWinViewer.html#a4">SoWinViewer::toggleCameraType()</a><p>
</li>
<li>
zoom out to exactly encompass all scene geometry within the view by using <a class="el" href="classSoWinViewer.html#a5">SoWinViewer::viewAll()</a><p>
</li>
<li>
tag a specific position and orientation for the camera as the "home" position with <a class="el" href="classSoWinViewer.html#a6">SoWinViewer::saveHomePosition()</a>, which one can then return to by using <a class="el" href="classSoWinViewer.html#a7">SoWinViewer::resetToHomePosition()</a><p>
</li>
<li>
automatically fit the near and far clipping planes of the camera around the scene's geometry by using SoWinViewer::setAutoClipping()<p>
</li>
<li>
control stereo viewing parameters<p>
</li>
</ul>
<p>
Note that there is no dragger or manipulator attached to the scene camera. The camera transform manipulation is calculated in a more direct manner in the non-abstract viewer classes inheriting SoWinViewer by reading mouse and keyboard events and interpreting how these should influence the camera. The calculations results in new values for SoCamera::position, SoCamera::orientation, and the other SoCamera field values for the camera designated to be the viewer viewpoint camera. These values are then inserted directly into the viewer's SoCamera node.<p>
See e.g. the source code for SoWinExaminerViewer::processSoEvent() for the details.<p>
The SoWinViewer class automatically adds a headlight to the scene, which will always point in the approximate same direction as the current viewer camera, thereby securing that the scene geometry is always lighted and visible. (If you don't want the constant headlight, but rather want to light the scene on your own, this behavior can be turned off with SoWinViewer::setHeadlight()).<p>
SoWinViewer-derived viewers all inherit the following keyboard controls from this class (but only when the viewer is in "examine mode", ie <a class="el" href="classSoWinViewer.html#a16">SoWinViewer::isViewing()</a> returns <code>TRUE</code>):<p>
<ul>
<li>
"s": put the viewer in "seek mode", where the end user may click anywhere on scene geometry to trigger an animation which moves the camera towards the point clicked<p>
</li>
<li>
"Home": hit this key to move camera back to last saved "home position"<p>
</li>
<li>
arrow keys: moves camera slightly left, right, up or down<p>
</li>
<li>
"q": exit application<p>
</li>
</ul>

<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#w25">Type</a> { <a class="el" href="classSoWinViewer.html#w25w0">BROWSER</a>, 
<a class="el" href="classSoWinViewer.html#w25w1">EDITOR</a>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#w26">DrawStyle</a> { <br>
&nbsp;&nbsp;<a class="el" href="classSoWinViewer.html#w26w2">VIEW_AS_IS</a>, 
<a class="el" href="classSoWinViewer.html#w26w3">VIEW_HIDDEN_LINE</a>, 
<a class="el" href="classSoWinViewer.html#w26w4">VIEW_NO_TEXTURE</a>, 
<a class="el" href="classSoWinViewer.html#w26w5">VIEW_LOW_COMPLEXITY</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classSoWinViewer.html#w26w6">VIEW_LINE</a>, 
<a class="el" href="classSoWinViewer.html#w26w7">VIEW_POINT</a>, 
<a class="el" href="classSoWinViewer.html#w26w8">VIEW_BBOX</a>, 
<a class="el" href="classSoWinViewer.html#w26w9">VIEW_LOW_RES_LINE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classSoWinViewer.html#w26w10">VIEW_LOW_RES_POINT</a>, 
<a class="el" href="classSoWinViewer.html#w26w11">VIEW_SAME_AS_STILL</a>, 
<a class="el" href="classSoWinViewer.html#w26w12">VIEW_WIREFRAME_OVERLAY</a>
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#w27">DrawType</a> { <a class="el" href="classSoWinViewer.html#w27w13">STILL</a> =  0, 
<a class="el" href="classSoWinViewer.html#w27w14">INTERACTIVE</a>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#w28">BufferType</a> { <a class="el" href="classSoWinViewer.html#w28w15">BUFFER_SINGLE</a>, 
<a class="el" href="classSoWinViewer.html#w28w16">BUFFER_DOUBLE</a>, 
<a class="el" href="classSoWinViewer.html#w28w17">BUFFER_INTERACTIVE</a>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#w29">AutoClippingStrategy</a> { <a class="el" href="classSoWinViewer.html#w29w18">VARIABLE_NEAR_PLANE</a>, 
<a class="el" href="classSoWinViewer.html#w29w19">CONSTANT_NEAR_PLANE</a>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#w30">StereoType</a> { <br>
&nbsp;&nbsp;<a class="el" href="classSoWinViewer.html#w30w20">STEREO_NONE</a>, 
<a class="el" href="classSoWinViewer.html#w30w21">STEREO_ANAGLYPH</a>, 
<a class="el" href="classSoWinViewer.html#w30w22">STEREO_QUADBUFFER</a>, 
<a class="el" href="classSoWinViewer.html#w30w23">STEREO_INTERLEAVED_ROWS</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classSoWinViewer.html#w30w24">STEREO_INTERLEAVED_COLUMNS</a>
<br>
 }</td></tr>

<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a0">setCamera</a> (SoCamera *camera)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SoCamera *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a1">getCamera</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a2">setCameraType</a> (SoType type)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SoType&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a3">getCameraType</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a4">toggleCameraType</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a5">viewAll</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a6">saveHomePosition</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a7">resetToHomePosition</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a8">setHeadlight</a> (SbBool enable)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a9">isHeadlight</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SoDirectionalLight *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a10">getHeadlight</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a11">setDrawStyle</a> (<a class="el" href="classSoWinViewer.html#w27">SoWinViewer::DrawType</a> type, <a class="el" href="classSoWinViewer.html#w26">SoWinViewer::DrawStyle</a> style)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classSoWinViewer.html#w26">SoWinViewer::DrawStyle</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a12">getDrawStyle</a> (const <a class="el" href="classSoWinViewer.html#w27">SoWinViewer::DrawType</a> type) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a13">setBufferingType</a> (<a class="el" href="classSoWinViewer.html#w28">SoWinViewer::BufferType</a> type)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classSoWinViewer.html#w28">SoWinViewer::BufferType</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a14">getBufferingType</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a15">setViewing</a> (SbBool enable)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a16">isViewing</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a17">setCursorEnabled</a> (SbBool enable)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a18">isCursorEnabled</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a19">setAutoClipping</a> (SbBool enable)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a20">isAutoClipping</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a21">setAutoClippingStrategy</a> (const <a class="el" href="classSoWinViewer.html#w29">AutoClippingStrategy</a> strategy, const float value=0.6f, SoWinAutoClippingCB *cb=NULL, void *cbuserdata=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a22">setStereoViewing</a> (SbBool enable)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a23">isStereoViewing</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a24">setStereoOffset</a> (const float dist)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>float&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a25">getStereoOffset</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a26">setStereoType</a> (<a class="el" href="classSoWinViewer.html#w30">SoWinViewer::StereoType</a> s)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classSoWinViewer.html#w30">SoWinViewer::StereoType</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a27">getStereoType</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a28">setAnaglyphStereoColorMasks</a> (const SbBool left[3], const SbBool right[3])</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a29">getAnaglyphStereoColorMasks</a> (SbBool left[3], SbBool right[3])</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a30">setDetailSeek</a> (const SbBool enable)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a31">isDetailSeek</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a32">setSeekTime</a> (const float seconds)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>float&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a33">getSeekTime</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a34">addStartCallback</a> (SoWinViewerCB *func, void *data=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a35">addFinishCallback</a> (SoWinViewerCB *func, void *data=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a36">removeStartCallback</a> (SoWinViewerCB *func, void *data=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a37">removeFinishCallback</a> (SoWinViewerCB *func, void *data=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a38">setWireframeOverlayColor</a> (const SbColor &amp;color)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>const SbColor &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a39">getWireframeOverlayColor</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a40">setDoubleBuffer</a> (const SbBool enable)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a41">setSceneGraph</a> (SoNode *root)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual SoNode *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#a42">getSceneGraph</a> (void)</td></tr>

<tr><td colspan=2><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#b0">SoWinViewer</a> (HWND parent, const char *name, SbBool embed, <a class="el" href="classSoWinViewer.html#w25">Type</a> type, SbBool build)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#b1">~SoWinViewer</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#b2">sizeChanged</a> (const SbVec2s &amp;size)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#b3">setSeekMode</a> (SbBool enable)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#b4">isSeekMode</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#b5">seekToPoint</a> (const SbVec2s screenpos)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#b6">computeSeekFinalOrientation</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#b7">actualRedraw</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#b8">processSoEvent</a> (const SoEvent *const event)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#b9">interactiveCountInc</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#b10">interactiveCountDec</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#b11">getInteractiveCount</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#b12">setSeekDistance</a> (const float distance)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>float&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#b13">getSeekDistance</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#b14">setSeekValueAsPercentage</a> (const SbBool on)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#b15">isSeekValuePercentage</a> (void) const</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#b16">changeCameraValues</a> (SoCamera *camera)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#b17">addSuperimposition</a> (SoNode *scene)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#b18">removeSuperimposition</a> (SoNode *scene)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#b19">setSuperimpositionEnabled</a> (SoNode *scene, const SbBool enable)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>SbBool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSoWinViewer.html#b20">getSuperimpositionEnabled</a> (SoNode *scene) const</td></tr>

</table>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="w25" doxytag="SoWinViewer::Type" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="classSoWinViewer.html#w25">SoWinViewer::Type</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Hints about what context the viewer will be used in. Usually not very interesting for the application programmer, it doesn't matter much which value is used for the viewer type. This "feature" of the viewer is included just to be compatible with the old SGI Inventor API. <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="w25w0" doxytag="BROWSER" ></a>BROWSER</em>&nbsp;</td><td>
If a user-supplied scenegraph passed into the setSceneGraph() function does not contain a camera, setting the viewer type to BROWSER will make the viewer in that case automatically set up a camera outside the scene, as part of the viewer's private and hidden "supergraph". </td></tr>
<tr><td valign=top><em><a class="anchor" name="w25w1" doxytag="EDITOR" ></a>EDITOR</em>&nbsp;</td><td>
If a user-supplied scenegraph passed into the setSceneGraph) function does not contain a camera, setting the viewer type to EDITOR will make the viewer in that case automatically set up a camera <em>in</em> the user-supplied scene.<p>
So if you want to avoid having the SoWinViewer class muck about with your supplied scenegraph, set the type-flag to <a class="el" href="classSoWinViewer.html#w25w0">SoWinViewer::BROWSER</a> instead. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="w26" doxytag="SoWinViewer::DrawStyle" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="classSoWinViewer.html#w26">SoWinViewer::DrawStyle</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Decides drawstyle for a scene with either a still camera or an animating camera.<p>
<dl compact><dt><b>See also:</b></dt><dd>SoWinViewer::setDrawStyle(), <a class="el" href="classSoWinViewer.html#w27">SoWinViewer::DrawType</a> </dd></dl>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="w26w2" doxytag="VIEW_AS_IS" ></a>VIEW_AS_IS</em>&nbsp;</td><td>
Normal rendering, draws all scene geometry in it's original style. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w26w3" doxytag="VIEW_HIDDEN_LINE" ></a>VIEW_HIDDEN_LINE</em>&nbsp;</td><td>
Draw scene in "hidden line" mode: that is, as wireframe with no "see-through".<p>
Note that this is actually an expensive way to render, as the scene must be rendered twice to achieve the effect of hiding lines behind the invisible geometry. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w26w4" doxytag="VIEW_NO_TEXTURE" ></a>VIEW_NO_TEXTURE</em>&nbsp;</td><td>
Render scene without textures. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w26w5" doxytag="VIEW_LOW_COMPLEXITY" ></a>VIEW_LOW_COMPLEXITY</em>&nbsp;</td><td>
Render all "complex" shape types with low complexity to improve rendering performance.<p>
"Complex shapes" in this context includes spheres, cones, cylinder, NURBS surfaces, and others which are tesselated to polygons before being rendered. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w26w6" doxytag="VIEW_LINE" ></a>VIEW_LINE</em>&nbsp;</td><td>
View all polygon geometry in wireframe mode. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w26w7" doxytag="VIEW_POINT" ></a>VIEW_POINT</em>&nbsp;</td><td>
Render only the vertex positions of the geometry. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w26w8" doxytag="VIEW_BBOX" ></a>VIEW_BBOX</em>&nbsp;</td><td>
View the scene's bounding boxes, instead of rendering the full geometry.<p>
A very efficient way of optimizing rendering performance for scenes with high primitive counts while moving the camera about is to set this mode for the <a class="el" href="classSoWinViewer.html#w27w14">SoWinViewer::INTERACTIVE</a> DrawType. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w26w9" doxytag="VIEW_LOW_RES_LINE" ></a>VIEW_LOW_RES_LINE</em>&nbsp;</td><td>
Render as wireframe and don't bother with getting them rendered correctly in depth. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w26w10" doxytag="VIEW_LOW_RES_POINT" ></a>VIEW_LOW_RES_POINT</em>&nbsp;</td><td>
Render as vertex points and don't bother with getting them rendered correctly in depth. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w26w11" doxytag="VIEW_SAME_AS_STILL" ></a>VIEW_SAME_AS_STILL</em>&nbsp;</td><td>
Always render a scene with an animating camera (ie <a class="el" href="classSoWinViewer.html#w27w14">SoWinViewer::INTERACTIVE</a> DrawType) in the same manner as scene with a still camera. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w26w12" doxytag="VIEW_WIREFRAME_OVERLAY" ></a>VIEW_WIREFRAME_OVERLAY</em>&nbsp;</td><td>
Render the scene as normal, but overlay a set of lines showing the contours of all polygons. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="w27" doxytag="SoWinViewer::DrawType" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="classSoWinViewer.html#w27">SoWinViewer::DrawType</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Contains valid values for the first argument to the SoWinViewer::setDrawStyle() call. Decides the effect of the second argument.<p>
<dl compact><dt><b>See also:</b></dt><dd>SoWinViewer::setDrawStyle(), <a class="el" href="classSoWinViewer.html#w26">SoWinViewer::DrawStyle</a> </dd></dl>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="w27w13" doxytag="STILL" ></a>STILL</em>&nbsp;</td><td>
If this value is passed as the first argument of SoWinViewer::setDrawStyle(), the second argument decides which draw style to use when the viewer camera is standing still in the same position with the same orientation -- i.e. when the end user is <em>not</em> interacting with the scene camera. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w27w14" doxytag="INTERACTIVE" ></a>INTERACTIVE</em>&nbsp;</td><td>
If this value is passed as the first argument of SoWinViewer::setDrawStyle(), the second argument decides which draw style to use when the end user is interacting with the scene camera, causing continuous animation redraws. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="w28" doxytag="SoWinViewer::BufferType" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="classSoWinViewer.html#w28">SoWinViewer::BufferType</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set of valid values for SoWinViewer::setBufferingType(). <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="w28w15" doxytag="BUFFER_SINGLE" ></a>BUFFER_SINGLE</em>&nbsp;</td><td>
Change underlying OpenGL canvas to be single-buffered. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w28w16" doxytag="BUFFER_DOUBLE" ></a>BUFFER_DOUBLE</em>&nbsp;</td><td>
Change underlying OpenGL canvas to be double-buffered. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w28w17" doxytag="BUFFER_INTERACTIVE" ></a>BUFFER_INTERACTIVE</em>&nbsp;</td><td>
Set up so animation rendering is done in a double-buffered OpenGL canvas, but ordinary rendering happens directly in the front-buffer.<p>
This mode can be useful with absurdly large scenes, as the rendering will <em>visibly</em> progress, and one will avoid having the end user wonder why nothing is happening while the scene is rendered to the back buffer in the default <a class="el" href="classSoWinViewer.html#w28w16">SoWinViewer::BUFFER_DOUBLE</a> mode. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="w29" doxytag="SoWinViewer::AutoClippingStrategy" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="classSoWinViewer.html#w29">SoWinViewer::AutoClippingStrategy</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enum for auto clipping strategy.<p>
<dl compact><dt><b>See also:</b></dt><dd>setAutoClippingStrategy() </dd></dl>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="w29w18" doxytag="VARIABLE_NEAR_PLANE" ></a>VARIABLE_NEAR_PLANE</em>&nbsp;</td><td>
Variable near plane auto clipping strategy. Explained in detail in the documentation for the SoWinViewer::setAutoClippingStrategy() method. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w29w19" doxytag="CONSTANT_NEAR_PLANE" ></a>CONSTANT_NEAR_PLANE</em>&nbsp;</td><td>
Constant near plane auto clipping strategy. Explained in detail in the documentation for the SoWinViewer::setAutoClippingStrategy() method. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="w30" doxytag="SoWinViewer::StereoType" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="classSoWinViewer.html#w30">SoWinViewer::StereoType</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Contains list of supported stereo rendering techniques.<p>
<dl compact><dt><b>See also:</b></dt><dd>SoWinViewer::setStereoType() </dd></dl>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="w30w20" doxytag="STEREO_NONE" ></a>STEREO_NONE</em>&nbsp;</td><td>
Use monoscopic rendering. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w30w21" doxytag="STEREO_ANAGLYPH" ></a>STEREO_ANAGLYPH</em>&nbsp;</td><td>
Render stereo by superimposing two images of the same scene, but with different color filters over the left and right view (or "eye").<p>
This is a way of rendering stereo which works on any display, using color-filter glasses. Such glasses are usually cheap and easy to come by.<p>
<dl compact><dt><b>See also:</b></dt><dd>setAnaglyphStereoColorMasks() </dd></dl>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="w30w22" doxytag="STEREO_QUADBUFFER" ></a>STEREO_QUADBUFFER</em>&nbsp;</td><td>
Render stereo by using OpenGL quad-buffers. This is the most common interface for stereo rendering for more expensive hardware devices, such as shutter glasses and polarized glasses.<p>
The well known Crystal Eyes glasses are commonly used with this type of stereo display. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w30w23" doxytag="STEREO_INTERLEAVED_ROWS" ></a>STEREO_INTERLEAVED_ROWS</em>&nbsp;</td><td>
Interleaving / interlacing rows from the left and right eye is another stereo rendering method requiring special hardware. One example of a provider of shutter glasses working with interleaved glasses is VRex:<p>
<a href="http://www.vrex.com/">http://www.vrex.com/</a> </td></tr>
<tr><td valign=top><em><a class="anchor" name="w30w24" doxytag="STEREO_INTERLEAVED_COLUMNS" ></a>STEREO_INTERLEAVED_COLUMNS</em>&nbsp;</td><td>
Same basic technique as <a class="el" href="classSoWinViewer.html#w30w23">SoWinViewer::STEREO_INTERLEAVED_ROWS</a>, only it is vertical lines that are interleaved / interlaced, instead of horizontal lines. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="b0" doxytag="SoWinViewer::SoWinViewer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SoWinViewer::SoWinViewer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">HWND&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>SbBool&nbsp;</td>
          <td class="mdname" nowrap> <em>embed</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classSoWinViewer.html#w25">SoWinViewer::Type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>SbBool&nbsp;</td>
          <td class="mdname" nowrap> <em>build</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructor. <em>parent</em>, <em>name</em> and <em>embed</em> are passed on to <a class="el" href="classSoWinRenderArea.html">SoWinRenderArea</a>, so see the documentation for our parent constructor for for more information on those.<p>
The <em>t</em> type setting hints about what context the viewer will be used in. Usually not very interesting for the application programmer, but if you want to make sure the SoWinViewer class doesn't muck about with your supplied scenegraph, set the type-flag to <a class="el" href="classSoWinViewer.html#w25w0">SoWinViewer::BROWSER</a>. (This "feature" of the viewer is included just to be compatible with the old SGI Inventor API.)<p>
The <em>build</em> flag decides whether or not to delay building the widgets / window which is going to make up the components of the viewer.     </td>
  </tr>
</table>
<a class="anchor" name="b1" doxytag="SoWinViewer::~SoWinViewer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SoWinViewer::~<a class="el" href="classSoWinViewer.html">SoWinViewer</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor.     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a0" doxytag="SoWinViewer::setCamera" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::setCamera           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SoCamera *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cam</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the camera we want the viewer to manipulate when interacting with the viewer controls.<p>
The camera passed in as an argument to this method <em>must</em> already be part of the viewer's scenegraph. You do <em>not</em> inject viewpoint cameras to the viewer with this method.<p>
You should rather insert a camera into the scene graph first (if necessary, often one will be present already), then register it as the camera used by the viewer controls with this method.<p>
If the application code doesn't explicitly set up a camera through this method, the viewer will automatically scan through the scenegraph to find a camera to use. If no camera is available in the scenegraph at all, it will set up it's own camera.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoWinViewer.html#a1">getCamera()</a> </dd></dl>

<p>
Reimplemented in <a class="el" href="classSoWinPlaneViewer.html#a3">SoWinPlaneViewer</a>, <a class="el" href="classSoWinExaminerViewer.html#a11">SoWinExaminerViewer</a>, <a class="el" href="classSoWinConstrainedViewer.html#a2">SoWinConstrainedViewer</a>, and <a class="el" href="classSoWinFlyViewer.html#a5">SoWinFlyViewer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="SoWinViewer::getCamera" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SoCamera * SoWinViewer::getCamera           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the camera currently used by the viewer for the user's main viewpoint.<p>
It <em>is</em> possible that this function returns <code>NULL</code>, for instance if there's no scenegraph present in the viewer. (This is mostly meant as a note for developers extending the <a class="el" href="classSoWin.html">SoWin</a> library, as application programmers usually controls if and when a viewer contains a scenegraph, and therefore know in advance if this method will return a valid camera pointer.)<p>
<dl compact><dt><b>See also:</b></dt><dd>setCamera() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="SoWinViewer::setCameraType" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::setCameraType           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SoType&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>t</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
When the viewer has to make its own camera as a result of the graph passed to setSceneGraph() not containing any camera nodes, this call can be made in advance to decide which type the camera will be of.<p>
Default is to use an SoPerspectiveCamera.<p>
If this method is called when there is a scene graph and a camera already set up, it will delete the old camera and set up a camera with the new type if the <em>t</em> type is different from that of the current camera.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoWinViewer.html#a3">getCameraType()</a> </dd></dl>

<p>
Reimplemented in <a class="el" href="classSoWinFlyViewer.html#a7">SoWinFlyViewer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="SoWinViewer::getCameraType" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SoType SoWinViewer::getCameraType           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns camera type which will be used when the viewer has to make its own camera.<p>
Note that this call does <em>not</em> return the current cameratype, as one might expect. Use <a class="el" href="classSoWinViewer.html#a1">getCamera()</a> and SoType::getTypeId() for that inquiry.<p>
<dl compact><dt><b>See also:</b></dt><dd>setCameraType() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="SoWinViewer::toggleCameraType" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::toggleCameraType           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
If the current camera is of perspective type, switch to orthographic, and vice versa.<p>
Automatically calls SoWinViewer::setCameraType() so the change will immediately take place.     </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="SoWinViewer::viewAll" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::viewAll           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reposition the current camera so we can see the complete scene. 
<p>
Reimplemented in <a class="el" href="classSoWinFlyViewer.html#a3">SoWinFlyViewer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="SoWinViewer::saveHomePosition" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::saveHomePosition           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Store the current camera settings for later retrieval with <a class="el" href="classSoWinViewer.html#a7">resetToHomePosition()</a>.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoWinViewer.html#a7">resetToHomePosition()</a> </dd></dl>

<p>
Reimplemented in <a class="el" href="classSoWinConstrainedViewer.html#a3">SoWinConstrainedViewer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="SoWinViewer::resetToHomePosition" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::resetToHomePosition           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Restore the saved camera settings.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoWinViewer.html#a6">saveHomePosition()</a> </dd></dl>

<p>
Reimplemented in <a class="el" href="classSoWinConstrainedViewer.html#a4">SoWinConstrainedViewer</a>, and <a class="el" href="classSoWinFlyViewer.html#a4">SoWinFlyViewer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="SoWinViewer::setHeadlight" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::setHeadlight           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SbBool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>on</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Turn the camera headlight on or off.<p>
Default is to have a headlight turned on.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoWinViewer.html#a9">isHeadlight()</a>, <a class="el" href="classSoWinViewer.html#a10">getHeadlight()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="SoWinViewer::isHeadlight" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoWinViewer::isHeadlight           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns status of the viewer headlight, whether it is on or off.<p>
<dl compact><dt><b>See also:</b></dt><dd>setHeadlight(), <a class="el" href="classSoWinViewer.html#a10">getHeadlight()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="SoWinViewer::getHeadlight" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SoDirectionalLight * SoWinViewer::getHeadlight           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the a pointer to the directional light node which is the viewer headlight.<p>
The fields of the node is available for user editing.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoWinViewer.html#a9">isHeadlight()</a>, setHeadlight() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="SoWinViewer::setDrawStyle" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::setDrawStyle           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSoWinViewer.html#w27">SoWinViewer::DrawType</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classSoWinViewer.html#w26">SoWinViewer::DrawStyle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>style</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set up a drawing style. The <em>type</em> argument specifies if the given <em>style</em> should be interpreted as the drawstyle during animation or when the camera is static.<p>
Default values for the drawing style is to render the scene "as is" in both still mode and while the camera is moving.<p>
See the documentation for the <em>DrawType</em> and <em>DrawStyle</em> for more information.<p>
<dl compact><dt><b>See also:</b></dt><dd>getDrawStyle() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="SoWinViewer::getDrawStyle" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classSoWinViewer.html#w26">SoWinViewer::DrawStyle</a> SoWinViewer::getDrawStyle           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSoWinViewer.html#w27">SoWinViewer::DrawType</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>type</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return current drawstyles for the given type (<em>STILL</em> or <em>INTERACTIVE</em>).<p>
<dl compact><dt><b>See also:</b></dt><dd>setDrawStyle() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="SoWinViewer::setBufferingType" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::setBufferingType           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSoWinViewer.html#w28">SoWinViewer::BufferType</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>type</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the viewer's buffer type. Available types are <code><a class="el" href="classSoWinViewer.html#w28w15">SoWinViewer::BUFFER_SINGLE</a></code>, <code><a class="el" href="classSoWinViewer.html#w28w16">SoWinViewer::BUFFER_DOUBLE</a></code> and <code><a class="el" href="classSoWinViewer.html#w28w17">SoWinViewer::BUFFER_INTERACTIVE</a></code>.<p>
(With a buffer type of <code><a class="el" href="classSoWinViewer.html#w28w17">SoWinViewer::BUFFER_INTERACTIVE</a></code>, the viewer will render with doublebuffering during user interaction and with single buffering otherwise.)<p>
Default is <code><a class="el" href="classSoWinViewer.html#w28w16">SoWinViewer::BUFFER_DOUBLE</a></code>.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoWinViewer.html#a14">getBufferingType()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="SoWinViewer::getBufferingType" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classSoWinViewer.html#w28">SoWinViewer::BufferType</a> SoWinViewer::getBufferingType           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the viewer's buffer type.<p>
<dl compact><dt><b>See also:</b></dt><dd>setBufferingType() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="SoWinViewer::setViewing" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::setViewing           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SbBool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>enable</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set view mode.<p>
If the view mode is on, user events will be caught and used to influence the camera position / orientation. If view mode is off, all events in the viewer canvas (like for instance keypresses or mouseclicks and -movements) will be passed along to the scene graph.<p>
Default is to have the view mode active.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoWinViewer.html#a16">isViewing()</a> </dd></dl>

<p>
Reimplemented in <a class="el" href="classSoWinFullViewer.html#a11">SoWinFullViewer</a>, <a class="el" href="classSoWinPlaneViewer.html#a2">SoWinPlaneViewer</a>, <a class="el" href="classSoWinExaminerViewer.html#a10">SoWinExaminerViewer</a>, and <a class="el" href="classSoWinFlyViewer.html#a2">SoWinFlyViewer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="SoWinViewer::isViewing" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoWinViewer::isViewing           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return state of view mode.<p>
<code>TRUE</code> means that the mode of the viewer is set such that user interaction with the mouse is used to modify the position and orientation of the camera.<p>
<dl compact><dt><b>See also:</b></dt><dd>setViewing() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="SoWinViewer::setCursorEnabled" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::setCursorEnabled           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SbBool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>on</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set whether or not the mouse cursor representation should be visible in the viewer canvas.<p>
Default value is on.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoWinViewer.html#a18">isCursorEnabled()</a> </dd></dl>

<p>
Reimplemented in <a class="el" href="classSoWinPlaneViewer.html#a4">SoWinPlaneViewer</a>, <a class="el" href="classSoWinExaminerViewer.html#a12">SoWinExaminerViewer</a>, and <a class="el" href="classSoWinFlyViewer.html#a6">SoWinFlyViewer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="SoWinViewer::isCursorEnabled" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoWinViewer::isCursorEnabled           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns visibility status of mouse cursor.<p>
<dl compact><dt><b>See also:</b></dt><dd>setCursorEnabled() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="SoWinViewer::setAutoClipping" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::setAutoClipping           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SbBool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>enable</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Turn on or off continuous automatic adjustments of the near and far clipping planes.<p>
If on, the distance from the camera position to the near and far planes will be calculated to be a "best fit" around the geometry in the scene, to maximize the "stretch" of values for the visible geometry in the z-buffer. This is important, as z-buffer resolution is usually limited enough that one will quickly see flickering in the rasterization of close polygons upon lousy utilization of the z-buffer.<p>
Automatic calculations of near and far clip planes are on as default.<p>
For better control over what happens in boundary conditions (for instance when the distance between near and far planes get very far, or if geometry gets very close to the camera position), it is possible to use the SoWinViewer::setAutoClippingStrategy() method to fine-tune the near/far clipping plane settings.<p>
On a major note, be aware that turning auto-updating of near and far clip planes have a potentially serious detrimental effect on performance, due to an important side effect: updating the near and far clip planes triggers an SoGetBoundingBoxAction to traverse the scene graph, which causes bounding boxes to be calculated and stored in caches. The bounding box caches are then used by the SoGLRenderAction traversal for view frustum culling operations. With no bounding box caches, the rendering will not do culling, which can cause much worse performance. Systems in Motion are working on correcting this problem properly from within the Coin library.<p>
On a minor note, be aware that notifications will be temporarily turned off for the scene's SoCamera when changing the near and far clipping planes (which is done right before each redraw). This is done to avoid notifications being sent through the scene graph right before rendering, as that causes some latency. It is mentioned here in case you have any client code which for some reason needs to sense all changes to the scene camera. This is however unlikely, so you can very probably ignore this.<p>
<dl compact><dt><b>See also:</b></dt><dd>getAutoClipping() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="SoWinViewer::isAutoClipping" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoWinViewer::isAutoClipping           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return value of the automatic near/far clipplane adjustment indicator.<p>
<dl compact><dt><b>See also:</b></dt><dd>setAutoClipping() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="SoWinViewer::setAutoClippingStrategy" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::setAutoClippingStrategy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSoWinViewer.html#w29">AutoClippingStrategy</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>strategy</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const float&nbsp;</td>
          <td class="mdname" nowrap> <em>value</em> = <code>0.6f</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>SoWinAutoClippingCB *&nbsp;</td>
          <td class="mdname" nowrap> <em>cb</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>cbuserdata</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the strategy used for automatic updates of the distances to the near and far clipping planes.<p>
When auto clipping is enabled, the near plane distance is calculated so that it is just in front of the scene bounding box. If this near plane is behind or very close to the projection point, one of the following strategies will be used to calculate the new clipping plane.<p>
The VARIABLE_NEAR_PLANE strategy considers the number of z buffer bits available for the current OpenGL context, and uses <em>value</em> to calculate the number of bits that is lost because of the far/near ratio. <em>value</em> should be in the range [0.0, 1.0]. A higher <em>value</em> will increase the z-buffer precision, but also push the near plane further away from the projection point.<p>
The CONSTANT_NEAR_PLANE strategy simply sets the near plane to <em>value</em>. If <em>value</em> at some point approaches the far clipping plane distance, the near plane distance will be set to far plane distance divided by 5000.0.<p>
The default strategy is VARIABLE_NEAR_PLANE.<p>
It is also possible to register a callback method <em>cb</em>, which will then be invoked after the near and far clipping planes has been calculated by the SoWinViewer code. The callback can then adjust the values for the distance to the near and far planes to exactly match the needs of the application (for instance at specific parts in the scene), to limit the distance to either plane, or whatever else needs to be controlled.<p>
The signature of the SoWinAutoClippingCB callback must match: <pre><div class="fragment">  SbVec2f myfunc(<span class="keywordtype">void</span> * data, <span class="keyword">const</span> SbVec2f &amp; nearfar);
</div></pre><p>
The first argument is the <em>cbuserdata</em> passed in along with the callback function pointer itself (ie the callback function's closure). The second argument is the near and far clipping plane distances from the camera position, as calculated internally by the viewer, including "slack".<p>
The function callback can then modify the near and far clipping plane distances to what will <em>actually</em> be used by the viewer. These values will then be used unmodified for the viewer's camera.<p>
This is a good way of dynamically modifying the near and far distances such that they at all times exactly matches the specific layout of the application scene, for instance with regard to the trade-off between z-buffer resolution and how early geometry is clipped at the near plane (or at the far plane).<p>
Note that the internal near/far calculations should be good enough for the vast majority of scenes. Application programmers should only need to set up their own adjustments upon "unusual" scenes, like for instance scenes with a large world space, but where one would still like to be able to get up extremely close on details in some parts of the scene.<p>
<dl compact><dt><b>See also:</b></dt><dd>setAutoClipping() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="SoWinViewer::setStereoViewing" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::setStereoViewing           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SbBool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>enable</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Turn stereo viewing on or off.<p>
Note: this function is being obsoleted, you should use the setStereoType() function instead.<p>
Coin does "correct" stereo rendering, using the method known as "parallel axis asymmetric frustum perspective projection". For more information, see this link:<p>
<a href="http://astronomy.swin.edu.au/~pbourke/opengl/stereogl/">http://astronomy.swin.edu.au/~pbourke/opengl/stereogl/</a><p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoWinViewer.html#a23">isStereoViewing()</a>, setStereoType() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="SoWinViewer::isStereoViewing" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoWinViewer::isStereoViewing           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a boolean indicating whether or not we're in stereo viewing mode.<p>
NOTE: in the original InventorXt API, this method was virtual. It is not virtual here.<p>
<dl compact><dt><b>See also:</b></dt><dd>setStereoViewing(), <a class="el" href="classSoWinViewer.html#a27">getStereoType()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="SoWinViewer::setStereoOffset" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::setStereoOffset           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const float&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dist</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the offset between the two viewpoints when in stereo mode. Default value is 0.1.<p>
NOTE: In the original InventorXt API, this method was not virtual.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoWinViewer.html#a25">getStereoOffset()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="SoWinViewer::getStereoOffset" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float SoWinViewer::getStereoOffset           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the offset distance between the two viewpoints when in stereo mode.<p>
<dl compact><dt><b>See also:</b></dt><dd>setStereoOffset() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="SoWinViewer::setStereoType" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoWinViewer::setStereoType           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSoWinViewer.html#w30">SoWinViewer::StereoType</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>s</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set up stereo rendering.<p>
Coin does "correct" stereo rendering, using the method known as "parallel axis asymmetric frustum perspective projection". For more information, see this link:<p>
<a href="http://astronomy.swin.edu.au/~pbourke/opengl/stereogl/">http://astronomy.swin.edu.au/~pbourke/opengl/stereogl/</a><p>
Note: it is prefered that one uses this function for control of which type of stereo rendering to use, instead of the older SoWinViewer::setStereoViewing() and SoWinGLWidget::setQuadBufferStereo() functions.<p>
The default is to do monoscopic rendering, i.e. the default <a class="el" href="classSoWinViewer.html#w30">SoWinViewer::StereoType</a> value is <a class="el" href="classSoWinViewer.html#w30w20">SoWinViewer::STEREO_NONE</a>.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoWinViewer.html#w30">SoWinViewer::StereoType</a> </dd></dl>
<dl compact><dt><b>Since:</b></dt><dd><a class="el" href="classSoWin.html">SoWin</a> 1.2 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a27" doxytag="SoWinViewer::getStereoType" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classSoWinViewer.html#w30">SoWinViewer::StereoType</a> SoWinViewer::getStereoType           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the current type of stereo rendering used (or <a class="el" href="classSoWinViewer.html#w30w20">SoWinViewer::STEREO_NONE</a> if monoscopic).     </td>
  </tr>
</table>
<a class="anchor" name="a28" doxytag="SoWinViewer::setAnaglyphStereoColorMasks" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::setAnaglyphStereoColorMasks           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const SbBool&nbsp;</td>
          <td class="mdname" nowrap> <em>left</em>[3], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const SbBool&nbsp;</td>
          <td class="mdname" nowrap> <em>right</em>[3]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
If display is configured to render in anaglyph stereo, this function can be used to control which filter is used for each eye.<p>
The default filters are red (i.e. color vector [TRUE,FALSE,FALSE]) for the left eye, and cyan (color vector [FALSE,TRUE,TRUE]) for the right eye.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoWinViewer.html#w30">SoWinViewer::StereoType</a>, setStereoType() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a29" doxytag="SoWinViewer::getAnaglyphStereoColorMasks" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::getAnaglyphStereoColorMasks           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SbBool&nbsp;</td>
          <td class="mdname" nowrap> <em>left</em>[3], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>SbBool&nbsp;</td>
          <td class="mdname" nowrap> <em>right</em>[3]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns color masks for left and right eye filters in anaglyph stereo.<p>
<dl compact><dt><b>See also:</b></dt><dd>setAnaglyphStereoColorMasks() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a30" doxytag="SoWinViewer::setDetailSeek" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::setDetailSeek           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const SbBool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>on</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Toggle between seeking to a point or seeking to an object.<p>
Default is to seek to a point.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoWinViewer.html#a31">isDetailSeek()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a31" doxytag="SoWinViewer::isDetailSeek" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoWinViewer::isDetailSeek           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a value indicating whether or not seeks will be performed to the exact point of picking or just towards the picked object.<p>
<dl compact><dt><b>See also:</b></dt><dd>setDetailSeek() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a32" doxytag="SoWinViewer::setSeekTime" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::setSeekTime           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const float&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>seconds</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the duration of animating the camera repositioning after a successful seek. Call with <em>seconds</em> equal to <em>0</em>.0 to make the camera jump immediately to the correct spot.<p>
Default value is 2 seconds.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoWinViewer.html#a33">getSeekTime()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a33" doxytag="SoWinViewer::getSeekTime" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float SoWinViewer::getSeekTime           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the camera repositioning duration following a seek action.<p>
<dl compact><dt><b>See also:</b></dt><dd>setSeekTime() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a34" doxytag="SoWinViewer::addStartCallback" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::addStartCallback           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SoWinViewerCB *&nbsp;</td>
          <td class="mdname" nowrap> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Add a function to call when user interaction with the scene starts.<p>
<dl compact><dt><b>See also:</b></dt><dd>removeStartCallback(), addFinishCallback() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a35" doxytag="SoWinViewer::addFinishCallback" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::addFinishCallback           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SoWinViewerCB *&nbsp;</td>
          <td class="mdname" nowrap> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Add a function to call when user interaction with the scene ends.<p>
<dl compact><dt><b>See also:</b></dt><dd>removeFinishCallback(), addStartCallback() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a36" doxytag="SoWinViewer::removeStartCallback" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::removeStartCallback           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SoWinViewerCB *&nbsp;</td>
          <td class="mdname" nowrap> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove one of the functions which has been set up to be called when user interaction with the scene starts.<p>
<dl compact><dt><b>See also:</b></dt><dd>addStartCallback(), removeFinishCallback() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a37" doxytag="SoWinViewer::removeFinishCallback" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::removeFinishCallback           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SoWinViewerCB *&nbsp;</td>
          <td class="mdname" nowrap> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove one of the functions which has been set up to be called when user interaction with the scene ends.<p>
<dl compact><dt><b>See also:</b></dt><dd>addFinishCallback(), removeStartCallback() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a38" doxytag="SoWinViewer::setWireframeOverlayColor" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::setWireframeOverlayColor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const SbColor &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>color</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the color of the overlay wireframe to <em>color</em>.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoWinViewer.html#a39">getWireframeOverlayColor()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a39" doxytag="SoWinViewer::getWireframeOverlayColor" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const SbColor &amp; SoWinViewer::getWireframeOverlayColor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the current color of the overlay wireframe. The default color is [1,0,0], ie pure red.<p>
<dl compact><dt><b>See also:</b></dt><dd>setWireframeOverlayColor() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a40" doxytag="SoWinViewer::setDoubleBuffer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::setDoubleBuffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const SbBool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>on</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Overloaded to update the local bufferingtype variable.<p>
<dl compact><dt><b>See also:</b></dt><dd>setBufferingType(), <a class="el" href="classSoWinViewer.html#a14">getBufferingType()</a> </dd></dl>

<p>
Reimplemented from <a class="el" href="classSoWinGLWidget.html#a2">SoWinGLWidget</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a41" doxytag="SoWinViewer::setSceneGraph" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::setSceneGraph           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SoNode *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>root</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Give the viewer a scenegraph to render and interact with. Overloaded from parent class so the viewer can add it's own nodes to control rendering in different styles, rendering with a headlight, etc.<p>
The <em>root</em> node will be inserted under the <em>viewer's</em> root node, which also covers the nodes necessary to implement the different preferences drawing style settings.<p>
If no camera is part of the scene graph under <em>root</em>, one will be added automatically.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoWinViewer.html#a42">getSceneGraph()</a>, setCameraType() </dd></dl>

<p>
Reimplemented from <a class="el" href="classSoWinRenderArea.html#a2">SoWinRenderArea</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a42" doxytag="SoWinViewer::getSceneGraph" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SoNode * SoWinViewer::getSceneGraph           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method returns a reference to the scene graph root node as set by the user.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoWinRenderArea.html#a37">SoWinRenderArea::getSceneManager()</a> </dd></dl>

<p>
Reimplemented from <a class="el" href="classSoWinRenderArea.html#a3">SoWinRenderArea</a>.    </td>
  </tr>
</table>
<a class="anchor" name="b2" doxytag="SoWinViewer::sizeChanged" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::sizeChanged           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const SbVec2s &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>size</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Called internally from within the <a class="el" href="classSoWin.html">SoWin</a> library when the widget embedded in a component changes it size, which is usually triggered by end-user interaction.<p>
This method is then invoked to notify the component that the size has changed. It is called from the top and all the way down to the bottom, the size being adjusted to take into account extra decorations having been added at each level in the component class hierarchy. 
<p>
Reimplemented from <a class="el" href="classSoWinRenderArea.html#b9">SoWinRenderArea</a>.
<p>
Reimplemented in <a class="el" href="classSoWinFullViewer.html#b2">SoWinFullViewer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="b3" doxytag="SoWinViewer::setSeekMode" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::setSeekMode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SbBool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>enable</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Put the viewer in or out of "waiting-to-seek" mode.<p>
If the user performs a mouse button click when the viewer is in "waiting-to-seek" mode, the camera will be repositioned so the camera focal point lies on the point of the geometry under the mouse cursor.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoWinViewer.html#b4">isSeekMode()</a>, setDetailSeek() </dd></dl>

<p>
Reimplemented in <a class="el" href="classSoWinPlaneViewer.html#b6">SoWinPlaneViewer</a>, <a class="el" href="classSoWinExaminerViewer.html#b9">SoWinExaminerViewer</a>, and <a class="el" href="classSoWinFlyViewer.html#b5">SoWinFlyViewer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="b4" doxytag="SoWinViewer::isSeekMode" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoWinViewer::isSeekMode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return a flag which indicates whether or not the viewer is in "waiting-to-seek" mode.<p>
(The actual animated translation will not occur until the end user really <em>starts</em> the seek operation, typically by clicking with the left mousebutton.)<p>
<dl compact><dt><b>See also:</b></dt><dd>setSeekMode() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b5" doxytag="SoWinViewer::seekToPoint" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoWinViewer::seekToPoint           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const SbVec2s&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>screenpos</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call this method to initiate a seek action towards the 3D intersection of the scene and the ray from the screen coordinate's point and in the same direction as the camera is pointing.<p>
Returns <code>TRUE</code> if the ray from the <em>screenpos</em> position intersect with any parts of the onscreen geometry, otherwise <code>FALSE</code>.     </td>
  </tr>
</table>
<a class="anchor" name="b6" doxytag="SoWinViewer::computeSeekFinalOrientation" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::computeSeekFinalOrientation           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method is obsoleted in Coin <a class="el" href="classSoWin.html">SoWin</a>.     </td>
  </tr>
</table>
<a class="anchor" name="b7" doxytag="SoWinViewer::actualRedraw" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::actualRedraw           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method instantly redraws the normal (non-overlay) scenegraph by calling SoSceneManager::render().<p>
Subclasses may override this method to add their own rendering before or after Coin renders it's scenegraph.<p>
The following is a complete example that demonstrates one way of adding both a background image and foreground (overlay) geometry to the "normal" rendering:<p>
<pre><div class="fragment">  <span class="comment">// This example shows how to put a permanent background image on your</span>
  <span class="comment">// viewer canvas, below the 3D graphics, plus overlay foreground</span>
  <span class="comment">// geometry.  Written by mortene.  Copyright Systems in Motion 2002.</span>
  
  <span class="comment">// *************************************************************************</span>
  
<span class="preprocessor">  #include &lt;Inventor/Win/SoWin.h&gt;</span>
<span class="preprocessor">  #include &lt;Inventor/Win/viewers/SoWinExaminerViewer.h&gt;</span>
<span class="preprocessor">  #include &lt;Inventor/nodes/SoBaseColor.h&gt;</span>
<span class="preprocessor">  #include &lt;Inventor/nodes/SoCone.h&gt;</span>
<span class="preprocessor">  #include &lt;Inventor/nodes/SoCube.h&gt;</span>
<span class="preprocessor">  #include &lt;Inventor/nodes/SoImage.h&gt;</span>
<span class="preprocessor">  #include &lt;Inventor/nodes/SoLightModel.h&gt;</span>
<span class="preprocessor">  #include &lt;Inventor/nodes/SoOrthographicCamera.h&gt;</span>
<span class="preprocessor">  #include &lt;Inventor/nodes/SoRotationXYZ.h&gt;</span>
<span class="preprocessor">  #include &lt;Inventor/nodes/SoSeparator.h&gt;</span>
<span class="preprocessor">  #include &lt;Inventor/nodes/SoTranslation.h&gt;</span>
  
<span class="preprocessor">  #include &lt;GL/gl.h&gt;</span>
  
  <span class="comment">// *************************************************************************</span>
  
  <span class="keyword">class </span>MyExaminerViewer : <span class="keyword">public</span> <a class="code" href="classSoWinExaminerViewer.html">SoWinExaminerViewer</a> {
  
  <span class="keyword">public</span>:
    MyExaminerViewer(HWND parent, <span class="keyword">const</span> <span class="keywordtype">char</span> * filename);
    ~MyExaminerViewer();
  
  <span class="keyword">protected</span>:
    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classSoWinViewer.html#b7">actualRedraw</a>(<span class="keywordtype">void</span>);
  
  <span class="keyword">private</span>:
    SoSeparator * bckgroundroot;
    SoSeparator * foregroundroot;
    SoRotationXYZ * arrowrotation;
  };
  
  MyExaminerViewer::MyExaminerViewer(HWND parent, <span class="keyword">const</span> <span class="keywordtype">char</span> * filename)
    : <a class="code" href="classSoWinExaminerViewer.html">SoWinExaminerViewer</a>(parent)
  {
    <span class="comment">// Coin should not clear the pixel-buffer, so the background image</span>
    <span class="comment">// is not removed.</span>
    this-&gt;<a class="code" href="classSoWinRenderArea.html#a20">setClearBeforeRender</a>(FALSE, TRUE);
  
  
    <span class="comment">// Set up background scenegraph with image in it.</span>
  
    this-&gt;bckgroundroot = <span class="keyword">new</span> SoSeparator;
    this-&gt;bckgroundroot-&gt;ref();
  
    SoOrthographicCamera * cam = <span class="keyword">new</span> SoOrthographicCamera;
    cam-&gt;position = SbVec3f(0, 0, 1);
    cam-&gt;height = 1;
    <span class="comment">// SoImage will be at z==0.0.</span>
    cam-&gt;nearDistance = 0.5;
    cam-&gt;farDistance = 1.5;
  
    SoImage * img = <span class="keyword">new</span> SoImage;
    img-&gt;vertAlignment = SoImage::HALF;
    img-&gt;horAlignment = SoImage::CENTER;
    img-&gt;filename = filename;
  
    this-&gt;bckgroundroot-&gt;addChild(cam);
    this-&gt;bckgroundroot-&gt;addChild(img);
  
    <span class="comment">// Set up foreground, overlayed scenegraph.</span>
  
    this-&gt;foregroundroot = <span class="keyword">new</span> SoSeparator;
    this-&gt;foregroundroot-&gt;ref();
  
    SoLightModel * lm = <span class="keyword">new</span> SoLightModel;
    lm-&gt;model = SoLightModel::BASE_COLOR;
  
    SoBaseColor * bc = <span class="keyword">new</span> SoBaseColor;
    bc-&gt;rgb = SbColor(1, 1, 0);
  
    cam = <span class="keyword">new</span> SoOrthographicCamera;
    cam-&gt;position = SbVec3f(0, 0, 5);
    cam-&gt;height = 10;
    cam-&gt;nearDistance = 0;
    cam-&gt;farDistance = 10;
  
    <span class="keyword">const</span> <span class="keywordtype">double</span> ARROWSIZE = 2.0;
  
    SoTranslation * posit = <span class="keyword">new</span> SoTranslation;
    posit-&gt;translation = SbVec3f(-2.5 * ARROWSIZE, 1.5 * ARROWSIZE, 0);
  
    arrowrotation = <span class="keyword">new</span> SoRotationXYZ;
    arrowrotation-&gt;axis = SoRotationXYZ::Z;
  
    SoTranslation * offset = <span class="keyword">new</span> SoTranslation;
    offset-&gt;translation = SbVec3f(ARROWSIZE/2.0, 0, 0);
  
    SoCube * cube = <span class="keyword">new</span> SoCube;
    cube-&gt;width = ARROWSIZE;
    cube-&gt;height = ARROWSIZE/15.0;
  
    this-&gt;foregroundroot-&gt;addChild(cam);
    this-&gt;foregroundroot-&gt;addChild(lm);
    this-&gt;foregroundroot-&gt;addChild(bc);
    this-&gt;foregroundroot-&gt;addChild(posit);
    this-&gt;foregroundroot-&gt;addChild(arrowrotation);
    this-&gt;foregroundroot-&gt;addChild(offset);
    this-&gt;foregroundroot-&gt;addChild(cube);
  }
  
  MyExaminerViewer::~MyExaminerViewer()
  {
    this-&gt;bckgroundroot-&gt;unref();
    this-&gt;foregroundroot-&gt;unref();
  }
  
  <span class="keywordtype">void</span>
  <a class="code" href="classSoWinExaminerViewer.html#b10">MyExaminerViewer::actualRedraw</a>(<span class="keywordtype">void</span>)
  {
    <span class="comment">// Must set up the OpenGL viewport manually, as upon resize</span>
    <span class="comment">// operations, Coin won't set it up until the SoGLRenderAction is</span>
    <span class="comment">// applied again. And since we need to do glClear() before applying</span>
    <span class="comment">// the action..</span>
    <span class="keyword">const</span> SbViewportRegion vp = this-&gt;<a class="code" href="classSoWinRenderArea.html#a15">getViewportRegion</a>();
    SbVec2s origin = vp.getViewportOriginPixels();
    SbVec2s size = vp.getViewportSizePixels();
    glViewport(origin[0], origin[1], size[0], size[1]);
  
    <span class="keyword">const</span> SbColor col = this-&gt;<a class="code" href="classSoWinRenderArea.html#a7">getBackgroundColor</a>();
    glClearColor(col[0], col[1], col[2], 0.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  
    <span class="comment">// Render our scenegraph with the image.</span>
    SoGLRenderAction * glra = this-&gt;<a class="code" href="classSoWinRenderArea.html#a41">getGLRenderAction</a>();
    glra-&gt;apply(this-&gt;bckgroundroot);
  
  
    <span class="comment">// Render normal scenegraph.</span>
    <a class="code" href="classSoWinExaminerViewer.html#b10">SoWinExaminerViewer::actualRedraw</a>();
  
  
    <span class="comment">// Increase arrow angle with 1/1000  every frame.</span>
    arrowrotation-&gt;angle = arrowrotation-&gt;angle.getValue() + (0.001 / M_PI * 180);
    <span class="comment">// Render overlay front scenegraph.</span>
    glClear(GL_DEPTH_BUFFER_BIT);
    glra-&gt;apply(this-&gt;foregroundroot);
  }
  
  <span class="comment">// *************************************************************************</span>
  
  <span class="keywordtype">int</span>
  main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv)
  {
    <span class="keywordflow">if</span> (argc != 2) {
      (<span class="keywordtype">void</span>)fprintf(stderr, <span class="stringliteral">"\n\n\tUsage: %s &lt;image-filename&gt;\n\n"</span>, argv[0]);
      exit(1);
    }
  
    HWND window = <a class="code" href="classSoWin.html#e0">SoWin::init</a>(argv[0]);
  
    MyExaminerViewer * viewer = <span class="keyword">new</span> MyExaminerViewer(window, argv[1]);
  
    viewer-&gt;setSceneGraph(<span class="keyword">new</span> SoCone);
    viewer-&gt;show();
  
    <a class="code" href="classSoWin.html#e8">SoWin::show</a>(window);
    <a class="code" href="classSoWin.html#e3">SoWin::mainLoop</a>();
  
    <span class="keyword">delete</span> viewer;
    <span class="keywordflow">return</span> 0;
  }
  
  <span class="comment">// *************************************************************************</span>
</div></pre>
<p>
Reimplemented from <a class="el" href="classSoWinRenderArea.html#b2">SoWinRenderArea</a>.
<p>
Reimplemented in <a class="el" href="classSoWinPlaneViewer.html#b7">SoWinPlaneViewer</a>, <a class="el" href="classSoWinExaminerViewer.html#b10">SoWinExaminerViewer</a>, and <a class="el" href="classSoWinFlyViewer.html#b6">SoWinFlyViewer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="b8" doxytag="SoWinViewer::processSoEvent" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoWinViewer::processSoEvent           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const SoEvent *const&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>event</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Toolkit-native events are attempted converted to Coin-generic events in the SoWinRenderArea::processEvent() method. If this succeeds, they are forwarded to this method.<p>
This is a virtual method, and is overridden in it's subclasses to catch events of particular interest to the viewer classes, for instance.<p>
Return <code>TRUE</code> iff the event was processed. If not it should be passed on further up in the inheritance hierarchy by the caller. This last point is extremely important to take note of if you are expanding the toolkit with your own viewer class.<p>
This method is not part of the original SGI InventorXt API. Note that you can still override the toolkit-native processEvent() method instead of this "generic" method. 
<p>
Reimplemented from <a class="el" href="classSoWinRenderArea.html#b5">SoWinRenderArea</a>.
<p>
Reimplemented in <a class="el" href="classSoWinFullViewer.html#b35">SoWinFullViewer</a>, <a class="el" href="classSoWinPlaneViewer.html#b5">SoWinPlaneViewer</a>, <a class="el" href="classSoWinExaminerViewer.html#b8">SoWinExaminerViewer</a>, and <a class="el" href="classSoWinFlyViewer.html#b4">SoWinFlyViewer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="b9" doxytag="SoWinViewer::interactiveCountInc" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::interactiveCountInc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
To be able to trigger callback functions when user interaction starts and/or stops, we need to keep track of the viewer state (i.e. are we in still mode or in animation mode?).<p>
SoWinViewer automatically adds callbacks to switch between still and moving draw style, and to switch between single/double buffer when the buffer type is <em>INTERACTIVE</em>.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoWinViewer.html#b10">interactiveCountDec()</a>, <a class="el" href="classSoWinViewer.html#b11">getInteractiveCount()</a> <p>
addStartCallback(), addFinishCallback() <p>
removeStartCallback(), removeFinishCallback() <p>
setDrawStyle(), setBufferingType() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b10" doxytag="SoWinViewer::interactiveCountDec" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::interactiveCountDec           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
To be able to trigger callback functions when user interaction starts and/or stops, we need to keep track of the viewer state (i.e. are we in still mode or in animation mode?).<p>
SoWinViewer automatically adds callbacks to switch between still and moving draw style, and to switch between single/double buffer when the buffer type is <em>INTERACTIVE</em>.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoWinViewer.html#b9">interactiveCountInc()</a>, <a class="el" href="classSoWinViewer.html#b11">getInteractiveCount()</a> <p>
addStartCallback(), addFinishCallback() <p>
removeStartCallback(), removeFinishCallback() <p>
setDrawStyle(), setBufferingType() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b11" doxytag="SoWinViewer::getInteractiveCount" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int SoWinViewer::getInteractiveCount           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return current interaction count nesting. If equal to zero, the viewer is in animation mode, otherwise the camera is still.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoWinViewer.html#b9">interactiveCountInc()</a>, <a class="el" href="classSoWinViewer.html#b10">interactiveCountDec()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b12" doxytag="SoWinViewer::setSeekDistance" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::setSeekDistance           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const float&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>distance</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the value used for calculating how close the camera and intersection hit point should be made at the end of a seek operation.<p>
The value can be interpreted as an absolute value in the given world unit (which typically is meters) or as a percentage value of the distance between the camera starting position and the intersection hit point. This can be controlled through the setSeekValueAsPercentage() method. It is as default used as an absolute value.<p>
Default value is 50 (absolute distance or percent).<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSoWinViewer.html#b13">getSeekDistance()</a>, setSeekValueAsPercentage(), setSeekTime() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b13" doxytag="SoWinViewer::getSeekDistance" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float SoWinViewer::getSeekDistance           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the current seek distance. Value given as an absolute scalar length or as a percentage value of the original distance between the hitpoint and the camera starting position.<p>
<dl compact><dt><b>See also:</b></dt><dd>setSeekDistance(), isSeekValueAsPercentage() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b14" doxytag="SoWinViewer::setSeekValueAsPercentage" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::setSeekValueAsPercentage           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const SbBool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>on</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Control whether or not the seek distance value should be interpreted as a percentage value or as an absolute distance. See documentation on setSeekDistance() for more information.<p>
<dl compact><dt><b>See also:</b></dt><dd>setSeekDistance(), isSeekValueAsPercentage() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b15" doxytag="SoWinViewer::isSeekValuePercentage" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoWinViewer::isSeekValuePercentage           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns an boolean which indicates if the seek distance value from <a class="el" href="classSoWinViewer.html#b13">getSeekDistance()</a> should be interpreted as a percentage value or as an absolute value.<p>
<dl compact><dt><b>See also:</b></dt><dd>setSeekValuePercentage(), <a class="el" href="classSoWinViewer.html#b13">getSeekDistance()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b16" doxytag="SoWinViewer::changeCameraValues" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::changeCameraValues           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SoCamera *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>camera</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copies the settings of <em>camera</em> into our current camera. Cameras must be of the same class type. 
<p>
Reimplemented in <a class="el" href="classSoWinConstrainedViewer.html#b5">SoWinConstrainedViewer</a>.    </td>
  </tr>
</table>
<a class="anchor" name="b17" doxytag="SoWinViewer::addSuperimposition" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::addSuperimposition           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SoNode *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>scene</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method is for setting up a superimposed scene graph on top of the viewer scene graph. It will be used for adding spin-rotation coordinate systems, fly-viewer speed indicators and similar things.<p>
This method is not part of the original InventorXt API.     </td>
  </tr>
</table>
<a class="anchor" name="b18" doxytag="SoWinViewer::removeSuperimposition" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::removeSuperimposition           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SoNode *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>scene</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method is not part of the original InventorXt API.     </td>
  </tr>
</table>
<a class="anchor" name="b19" doxytag="SoWinViewer::setSuperimpositionEnabled" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void SoWinViewer::setSuperimpositionEnabled           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SoNode *&nbsp;</td>
          <td class="mdname" nowrap> <em>scene</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const SbBool&nbsp;</td>
          <td class="mdname" nowrap> <em>enable</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method sets whether the superimposed scene graph should be traversed or not.<p>
This method is not part of the original InventorXt API.     </td>
  </tr>
</table>
<a class="anchor" name="b20" doxytag="SoWinViewer::getSuperimpositionEnabled" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> SbBool SoWinViewer::getSuperimpositionEnabled           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SoNode *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>scene</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method returns whether the superimposed scene is rendered or not.<p>
This method is not part of the original InventorXt API.     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="SoWinViewer_8h-source.html">SoWinViewer.h</a><li>SoWinViewer.cpp</ul>
<hr noshade>
<p align="right">Copyright &copy 1998-2004 by <a href="http://www.sim.no">Systems in Motion AS</a>. All rights reserved.</p>
<address style="align: right;"><small>
Generated on Mon Oct 18 01:40:29 2004 for SoWin by <a href="http://www.doxygen.org/index.html">Doxygen.</a> 1.3.7</small></address>
</body>
</html>
